---
output: html_document
editor_options: 
  chunk_output_type: inline
---

<!-- CSS options for custom title numbers styling-->
<style>
.header-section-number:after {
  content: ". ";
}
</style>

### Preliminary Set-up {.unnumbered}

::: {.callout-note collapse="true"}

#### Datasets, code availability, software, setup

##### Data

The folder containing this HTML file also has a "`data/`" folder, wherein can be found the main Excel file from which the datasets analysed here are sourced, i.e. "`raw_data_lena.xlsx`". 

<!-- The original first nine sheets have been merged into a single table and tidied in the setup code below: the resulting table has been exported in the tenth sheet. -->

##### Code availability and software

The code generating all the computations, figures, tables, etc. (only partially exposed here for clarity) can be found in the `2310-lena-analyses.qmd` file, for which the best reading software are coding Integrated Development Environments (IDE) like [RStudio](https://posit.co/download/rstudio-desktop/) or [Visual Studio Code](https://code.visualstudio.com/). The file includes detailed commentaries along with the code to ease understanding, accessibility, and potential (welcome) criticism.

This analysis was conducted in R language on [RStudio](https://posit.co/download/rstudio-desktop/). This analysis report was written with [Quarto](https://quarto.org/). 

##### Setup

Just down below is the setup code, including two essential steps: 

1. Installing the required packages for this data analysis

2. importing data into the dataframes used throughout. 

I left this (usually hidden) step here for reference of the tools used in a view of transparency for the interested reader.

```{r setup}
#| output: false
#| echo: true
#| code-summary: "Packages"

# The package `librairian` will ease the package management with the "shelf" 
# function, which automatically: 
# 1) checks if a package is installed 
# 2) installs it if need be
# 3) loads the package like the "library()" function would.
if (!require(librarian)) install.packages(librarian)
library(librarian)

# now putting packages on our library's shelves:
shelf(
  # --- essential package collections ---
  tidyverse,      # modern R ecosystem
  easystats,      # data analysis framework
  tidymodels,     # modelling framework
  
  # --- tidymodels friends
  corrr,          # correlational analyses
  tidybayes,      # bayesian inference
  multilevelmod,  # multilevel modelling with lmer and tidymodels
  
  # --- modelling
  lme4,           # mixed models
  mclust,         # mixture clustering
  rstanarm,       # bayesian models
  BayesFactor,    # BFs
  
  # --- data management
  readxl,         # importing xlsx
  openxlsx,       # exporting xlsx
  
  # --- data visualization
  # plot types and geoms
  ricardo-bion/ggradar,  # radar plots
  ggbeeswarm,            # scatter violin plots
  GGally,         # complex plots
  # layout and options
  ggpubr,         # publication plots
  patchwork,      # layout control
  rstatix,        # ggplot stat tools
  # palettes
  ggsci,          # scientific palettes
  viridis,        # colour-blind friendly palettes
  # interactive
  plotly         # interactive plots
)

theme_set(theme_bw(base_size = 14)) # global ggplot theme
set.seed(89910514) # fixing a seed for reproducibility

```

```{r importing_data}
#| echo: true
#| code-summary: "Importing data"

path <- "data/raw_data_lena.xlsx"
#_______________________________________________________________________________

# The raw data being magnificently tidy from the get-go, we only need to stack
# the successive dataframes on top of each other
df <-
  bind_rows(
    read_excel(path, sheet = "Session 1", range = "B1:V142"),
    read_excel(path, sheet = "Session 2", range = "B1:V142"),
    read_excel(path, sheet = "Session 3", range = "B1:V142"),
    read_excel(path, sheet = "Session 4", range = "B1:V142"),
    read_excel(path, sheet = "Session 5", range = "B1:V142"),
    read_excel(path, sheet = "Session 6", range = "B1:V142"),
    read_excel(path, sheet = "Session 7", range = "B1:V142"),
    read_excel(path, sheet = "Session 8", range = "B1:V142"),
    read_excel(path, sheet = "Session 9", range = "B1:V142")
  ) |> 
  # removing irrelevant columns
  select(-c(
    "date de naissance",
    age_bis, 
    genre, 
    personnages,
    "FR-Categ",
    "FR-Non categ",
    "SAM-Valence",
    "SAM-Intensité"
    )
  ) |>  
  rename(
    group     = "Groupe",
    subject   = "Pseudonyme",
    man       = "genre_bis",
    comprehension  = "histoire",
    categorization = "intrus",
    visuo_spatial = "puzzles",
    reco          = "reconnaissance",
    false_reco    = "Fausses-Reco",
    vis_spa_wm    = "mdt-visuo",
    attention     = "barrages"
  ) |>  
  mutate(
    # subject ids in lower case
    subject = tolower(subject),
    # group renaming
    group = if_else(group == "Contrôle", "control", group),
    # creating a meta group for expe vs control
    expe_group = ifelse(group != "control", "expe_group", group),
    # false_reco is reverse-coded
    false_reco = 20 - false_reco
  ) |>  
  mutate(across(c(
    group, 
    expe_group, 
    subject, 
    man:session), 
    ~ as.factor(.x))
  ) |> 
  # filtering out missing evaluations
  filter(
    !is.na(age) &
    !is.na(comprehension) & 
    !is.na(categorization) & 
    !is.na(visuo_spatial)
  ) |>
  # filling the rare remaining NAs
  fill(everything()) |> 
  # reordering
  select(group, expe_group, everything())
```

```{r na_check}
# NA check
# df |> summarise(across(everything(), ~sum(is.na(.x))))
```

:::

:::{.callout-tip appearance="simple"}

#### Interactive figures

Many figures in this report are interactive: hover over the plots to see some of the tools available. You can select a zone to zoom on a plot, hover over bars to see details about data, select only specific groups in the legend, among many other features.

:::

# Exploratory Data Analysis

The study was conducted on 141 second grade children scattered in five very similar schools from the same district: they were divided into five groups approximately following this distribution, as shown in @tbl-group_repartition. They followed a training curriculum consisting of four different learning modalities, each repeated twice in the year across eight sessions + the first test (coded here as *session 1*).

```{r}
#| label: tbl-group_repartition
#| tbl-cap: "Number of children in each experimental group."
#| column: margin

df |>
  group_by(group, subject) |> 
  summarise() |> 
  count() |> 
  ungroup() |> 
  rename(
    N = n,
    Group = group
  ) |>
  mutate(Group = ifelse(Group == "control", "Control", Group)) |> 
  display()
```

A distinctive feature of the study's tests is that they were modified over time to adapt to children's progression and avoid ceiling effects. Therefore, an analysis of raw scores could lead to *negative* differences between sessions (as tests are harder), that could be interpreted as a regression of the student. These difficulty variations make it useless to compare raw scores between sessions and conditions. Consequently, to assess the level of the children, We will center the scores for each test on the average level of all children across groups ***per session***: the score of a child to a given test in a given session will thus be evaluated only *relatively* to the score of other students. In the end, each outcome variable in each session will have a mean of 0 representing the average level in the whole sample at this point in time. 

```{r standardizing}
#| echo: true
#| code-summary: Standardizing per session

df_norm <- 
  df |>
  group_by(session) |> 
  mutate(across(comprehension:attention, ~as.numeric(scale(.x))))
```

## Correlations

Let's see the distributions and correlations between our various **outcomes**. The results of the Bayesian correlations between the variables are displayed in @fig-cor_matrix and the distributions in @fig-distributions.

:::{.panel-tabset .column-page-right}

#### Correlation between scores

```{r correlations}
#| label: fig-cor_matrix
#| fig-cap: "Correlation between the main outcomes of the study. The stars indicate the amount of evidence in favour of a correlation, as assessed by the $BF_{10}$: No star = Anecdotal evidence, * = Weak evidence, ** = Moderate evidence, *** = Extreme evidence."
#| fig-width: 10
#| fig-height: 7

df_norm |>
  ungroup() |> 
  select(comprehension:attention) |> 
  correlation(
    bayesian = TRUE,
    bayesian_test = "bf"
  ) |> 
  summary() |> 
  plot(
    labs = list(title = "")
  ) + 
  scale_fill_viridis(
    option = "D",
    # guide = NULL,
    alpha = .6,
    direction = 1,
    limits = c(-.3,.3)
  ) +
  theme_bw() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 14)
    )
```

#### Distribution of the scores

```{r distributions}
#| label: fig-distributions
#| fig-cap: "Distribution of the seven main outcomes of the study."
#| fig-width: 10
#| fig-height: 6

# (
df_norm |> 
  select(session, comprehension:attention) |> 
  pivot_longer(cols = comprehension:attention) |> 
  ggplot(aes(x = value, color = session, fill = session)) +
  geom_density(alpha = .4) +
  scale_color_viridis_d(name = "Session") +
  scale_fill_viridis_d(name  = "Session") +
  labs(x = "Standardized score", y = "Density") +
  facet_wrap(
    facets = vars(name), 
    nrow = 2,
    labeller = labeller(name = c(
      attention = "Attention",
      categorization = "Categorization",
      comprehension = "Comprehension",
      false_reco = "False recognition",
      reco = "Recognition",
      vis_spa_wm = "Visuo-spatial WM",
      visuo_spatial = "Visuo-spatial test"))
    )
# ) |> ggplotly()
```

:::

As we can see, several scores are significantly correlated (although with modest effect sizes), including some of the main tests, namely *comprehension*, *categorization* and *recognition* - among others. This suggests that, beyond their specificities, these tests might reflect common (cognitive) characteristics of the participants, e.g. in this case supposedly a "general ability level" of the child. To materialize this "general" variable, we will run a **Principal Component Analysis** and see if the different scores could be "merged" into a single variable (a "component", in PCA terms).

## Principal Component Analysis {#sec-pca}

```{r pca}
#| code-summary: "Computing the PCA"
#| echo: true

# --- Principal Component Analysis ---
pca <- 
  principal_components(
    df_norm[,8:14],
    n = "max",
    sort = TRUE,
    standardize = TRUE
    ) 
```

The resulting components of this PCA are displayed in @fig-loadings and @tbl-eigenvalues.

:::{layout-nrow=1}

```{r loadings}
#| label: fig-loadings
#| fig-cap: "Loadings of each variable on the six components extracted by a PCA (i.e. correlations between components and variables)."
#| fig-width: 9
#| fig-height: 6

# --- Loadings ---
pca |> 
  plot() + 
  facet_wrap(facets = vars(Component), nrow = 2) +
  scale_fill_viridis(alpha = .6) +
  labs(title = NULL) +
  theme(text = element_text(size = 14))
```

:::{.column-margin}

```{r eigenvalues}
#| label: tbl-eigenvalues
#| tbl-cap: "Eigenvalues and variance explained by the six components extracted by a PCA."
#| column: margin

# --- Eigenvalues and variance ---
pca |> 
  summary() |>
  pivot_longer(cols = -Parameter) |>
  pivot_wider(names_from = Parameter) |>
  rename("Component" = name) |>
  display()
```

:::

:::

The PCA can be interpreted as follows:

- As seen in @fig-cor_matrix, *comprehension*, *recognition*, *categorization* and *visuo-spatial test* scores are tightly correlated: in turn, the PCA aligned the **first component PC1** on these four variables, as shown by the coefficients of PC1 in @fig-loadings. We could interpret this first "concatenated" variable as "***reasoning***", to use a broad term at the intersection of the four tests. PC1 will be reversed to correlate positively with the four variables and ease interpretability. 

- The **second component PC2** is highly correlated with *false recognition scores*, which indeed correlate very weakly with the other variables (see @fig-cor_matrix). Thus, PC2 aligns with this score to capture the variability brought by it. We'll keep it named "***false recognition***", although the variable deviated a bit from the original one. 

- The **third component PC3** is correlated with *visuo-spatial working memory*, *attention*, and *false recognition*. It can be noted that, besides false recognition, this correlation (and subsequent component) between visuo-spatial WM and attention interestingly lines up with the **TBRS model**. Thus, PC3 will be named ***working memory***. 

The number of PCA components to keep as meaningful to explain the data can be assessed with the Eigenvalues and the variance explained by each of the components: as a rule of thumb, an Eigenvalue very close or superior to 1 denotes a good PCA component. In our case, only the first three components meet this criteria, as shown in @tbl-eigenvalues. These three components explain 56% of the total variance in the sample. Let's predict these new variables for each participant and add them to the data.

```{r pca_components}
#| code-summary: "Adding the predicted PCA components to the data"
#| echo: true

pca_components <- pca |> predict()

df_pca <-
  bind_cols(df_norm, pca_components[,1:3]) |> 
  mutate(
    PC1 = -c(scale(PC1)),
    PC2 = c(scale(PC2)),
    PC3 = c(scale(PC3))
    ) |> 
  rename(
    "pca_reasoning"  = PC1,
    "pca_false_reco" = PC2,
    "pca_wm"         = PC3
    )
```

Let's see how these components behave in @fig-pca_distributions and @fig-cor_pca.

:::{.column-page-right}

:::{.panel-tabset}

#### Correlation between components and scores

```{r cor_pca}
#| label: fig-cor_pca
#| fig-cap: "Correlation between the PCA components. The stars indicate the amount of evidence in favour of a correlation, as assessed by the $BF_{10}$: No star = Anecdotal evidence, * = Weak evidence, ** = Moderate evidence, *** = Extreme evidence."
#| fig-width: 14
#| fig-height: 10

df_pca |>
  ungroup() |> 
  select(comprehension:pca_wm) |> 
  correlation(
    bayesian = TRUE,
    bayesian_test = "bf"
  ) |> 
  summary() |> 
  plot(
    labs = list(title = "")
  ) + 
  scale_fill_viridis(
    option = "D",
    # guide = NULL,
    alpha = .6,
    direction = 1,
    limits = c(-.8, .8)
  ) +
  theme_bw() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 14)
    )
```

#### Distribution of the new PCA components

```{r pca_distributions}
#| label: fig-pca_distributions
#| fig-cap: "Distribution of the three components extracted by the PCA."
#| fig-width: 16
#| fig-height: 8

(df_pca |> 
  select(session, pca_reasoning:pca_wm) |> 
  pivot_longer(cols = pca_reasoning:pca_wm) |> 
  ggplot(aes(x = value, color = session, fill = session)) +
  geom_density(alpha = .4) +
  scale_color_viridis_d(name = "Session") +
  scale_fill_viridis_d(name = "Session") +
  labs(x = "Score", y = "Density") 
  ) |> 
  facet(
    facet.by = "name",
    panel.labs = list(name = c(
      "Reasoning",
      "False recognition",
      "Working memory"))
  ) |> 
  ggplotly()
```

:::

:::

As expected from the PCA, the three components are now completely decorrelated (bottom left corner of @fig-cor_pca) and show the relevant correlations with the initial scores mentioned above. The analyses that will follow could be conducted on each outcome variable individually or on the PCA components - thus assuming that they better represent the cognitive processes at play. Let's examine each individual outcome.

## Examining trends

### Conditions

One goal of the study was to show the impact of different training conditions on the progression of the children. The group division was created as a *counter-balancing* variable, to account for the effect of the order of the successive training conditions across weeks. Therefore, we do not have a data structure that allows us to study the effect of each individual condition on the outcomes *across time*^[We would have needed groups dedicated to a single condition, or every group with every condition at every session, which does not make sense in reality.], but only the effect of each condition **on the outcome of the next test**, i.e. the performance of the child directly after having been trained in one condition. Following this reasoning, the effect of the session on the condition differences is assumed to be controlled with the group repartition^[Although we could consider modelling them all together later. For this visualization, it still makes more sense to put the session factor aside.]. Let's visualize this effect on our outcome variables, across conditions and for each children in each experimental group, in @fig-comprehension_per_condition and all subsequent tabs.

:::{.panel-tabset .column-page-right}

#### Comprehension

```{r plot_comprehension}
#| label: fig-comprehension_per_condition
#| fig-cap: "Comprehension standardized scores per condition and group. ***Feel free to click on the legend.*** Colored points and dotted lines represent group means for each condition. The black dotted line is the standardized mean for every condition, i.e. 0 after the centering. Black points and lines represent condition means along with 95% confidence intervals."
#| fig-height: 7

df_comprehension <-
  df_pca |>
  filter(group != "control" & condition != 0) |>
  group_by(group, condition) |>
  get_summary_stats(comprehension)

(
df_pca |>
  filter(group != "control" & condition != 0) |>
  ggplot(aes(
    x = factor(condition, level = c("4", "3", "2", "1")),
    y = comprehension
  )) +
  geom_hline(
    yintercept = mean(df_pca$comprehension),
    linetype = 2
    ) +
  geom_beeswarm(aes(
    group = group,
    color = group
    ),
    alpha = .4
  ) +
  geom_line(
    data = df_comprehension,
    aes(
      x = condition,
      y = mean,
      group = group,
      color = group
      ),
    linetype = 3
  ) +
  geom_point(
    data = df_comprehension,
    aes(
      x = condition,
      y = mean,
      group = group,
      color = group)
  ) +
  geom_pointrange(
    data = df_pca |>
      filter(group != "control" & condition != 0) |>
      group_by(condition) |>
      get_summary_stats(comprehension),
    aes(
      x = condition,
      y = mean,
      ymin = mean - ci,
      ymax = mean + ci
      ),
    color = "black",
    size = 2
  ) +
  geom_line(
    data = df_pca |>
      filter(group != "control" & condition != 0) |>
      group_by(condition) |>
      get_summary_stats(comprehension),
    aes(
      x = condition,
      y = mean,
      group = 1
      ),
    color = "black",
    size = 1
  ) +
  coord_cartesian(ylim = c(-2,2)) +
  scale_color_viridis_d(name = "Group") +
  labs(x = "Condition", y = "Comprehension score (standardized)")
) |>
  ggplotly()
```


#### Categorization

```{r plot_categorization}
#| label: fig-categorization_per_condition
#| fig-cap: "Categorization standardized scores per condition and group. ***Feel free to click on the legend.*** Colored points and dotted lines represent group means for each condition. The black dotted line is the standardized mean for every condition, i.e. 0 after the centering. Black points and lines represent condition means along with 95% confidence intervals."
#| fig-height: 7

df_categorization <-
  df_pca |>
  filter(group != "control" & condition != 0) |>
  group_by(group, condition) |>
  get_summary_stats(categorization)

(
df_pca |>
  filter(group != "control" & condition != 0) |>
  ggplot(aes(
    x = factor(condition, level = c("4", "3", "2", "1")),
    y = categorization
  )) +
  geom_hline(
    yintercept = mean(df_pca$categorization),
    linetype = 2
    ) +
  geom_beeswarm(aes(
    group = group,
    color = group
    ),
    alpha = .4
  ) +
  geom_line(
    data = df_categorization,
    aes(
      x = condition,
      y = mean,
      group = group,
      color = group
      ),
    linetype = 3
  ) +
  geom_point(
    data = df_categorization,
    aes(
      x = condition,
      y = mean,
      group = group,
      color = group)
  ) +
  geom_pointrange(
    data = df_pca |>
      filter(group != "control" & condition != 0) |>
      group_by(condition) |>
      get_summary_stats(categorization),
    aes(
      x = condition,
      y = mean,
      ymin = mean - ci,
      ymax = mean + ci
      ),
    color = "black",
    size = 2
  ) +
  geom_line(
    data = df_pca |>
      filter(group != "control" & condition != 0) |>
      group_by(condition) |>
      get_summary_stats(categorization),
    aes(
      x = condition,
      y = mean,
      group = 1
      ),
    color = "black",
    size = 1
  ) +
  coord_cartesian(ylim = c(-2,2)) +
  scale_color_viridis_d(name = "Group") +
  labs(x = "Condition", y = "Categorization score (standardized)")
) |>
  ggplotly()
```


#### Visuo-spatial test

```{r plot_visuo_spatial}
#| label: fig-visuo_spatial_per_condition
#| fig-cap: "Visuo-spatial test standardized scores per condition and group. ***Feel free to click on the legend.*** Colored points and dotted lines represent group means for each condition. The black dotted line is the standardized mean for every condition, i.e. 0 after the centering. Black points and lines represent condition means along with 95% confidence intervals."
#| fig-height: 7

df_visuo_spatial <-
  df_pca |>
  filter(group != "control" & condition != 0) |>
  group_by(group, condition) |>
  get_summary_stats(visuo_spatial)

(
df_pca |>
  filter(group != "control" & condition != 0) |>
  ggplot(aes(
    x = factor(condition, level = c("4", "3", "2", "1")),
    y = visuo_spatial
  )) +
  geom_hline(
    yintercept = mean(df_pca$visuo_spatial),
    linetype = 2
    ) +
  geom_beeswarm(aes(
    group = group,
    color = group
    ),
    alpha = .4
  ) +
  geom_line(
    data = df_visuo_spatial,
    aes(
      x = condition,
      y = mean,
      group = group,
      color = group
      ),
    linetype = 3
  ) +
  geom_point(
    data = df_visuo_spatial,
    aes(
      x = condition,
      y = mean,
      group = group,
      color = group)
  ) +
  geom_pointrange(
    data = df_pca |>
      filter(group != "control" & condition != 0) |>
      group_by(condition) |>
      get_summary_stats(visuo_spatial),
    aes(
      x = condition,
      y = mean,
      ymin = mean - ci,
      ymax = mean + ci
      ),
    color = "black",
    size = 2
  ) +
  geom_line(
    data = df_pca |>
      filter(group != "control" & condition != 0) |>
      group_by(condition) |>
      get_summary_stats(visuo_spatial),
    aes(
      x = condition,
      y = mean,
      group = 1
      ),
    color = "black",
    size = 1
  ) +
  coord_cartesian(ylim = c(-2,2)) +
  scale_color_viridis_d(name = "Group") +
  labs(x = "Condition", y = "Visuo-spatial test score (standardized)")
) |>
  ggplotly()
```


#### Recognition

```{r plot_recognition}
#| label: fig-recognition_per_condition
#| fig-cap: "Recognition test standardized scores per condition and group. ***Feel free to click on the legend.*** Colored points and dotted lines represent group means for each condition. The black dotted line is the standardized mean for every condition, i.e. 0 after the centering. Black points and lines represent condition means along with 95% confidence intervals."
#| fig-height: 7

df_reco <-
  df_pca |>
  filter(group != "control" & condition != 0) |>
  group_by(group, condition) |>
  get_summary_stats(reco)

(
df_pca |>
  filter(group != "control" & condition != 0) |>
  ggplot(aes(
    x = factor(condition, level = c("4", "3", "2", "1")),
    y = reco
  )) +
  geom_hline(
    yintercept = mean(df_pca$reco),
    linetype = 2
    ) +
  geom_beeswarm(aes(
    group = group,
    color = group
    ),
    alpha = .4
  ) +
  geom_line(
    data = df_reco,
    aes(
      x = condition,
      y = mean,
      group = group,
      color = group
      ),
    linetype = 3
  ) +
  geom_point(
    data = df_reco,
    aes(
      x = condition,
      y = mean,
      group = group,
      color = group)
  ) +
  geom_pointrange(
    data = df_pca |>
      filter(group != "control" & condition != 0) |>
      group_by(condition) |>
      get_summary_stats(reco),
    aes(
      x = condition,
      y = mean,
      ymin = mean - ci,
      ymax = mean + ci
      ),
    color = "black",
    size = 2
  ) +
  geom_line(
    data = df_pca |>
      filter(group != "control" & condition != 0) |>
      group_by(condition) |>
      get_summary_stats(reco),
    aes(
      x = condition,
      y = mean,
      group = 1
      ),
    color = "black",
    size = 1
  ) +
  coord_cartesian(ylim = c(-2,2)) +
  scale_color_viridis_d(name = "Group") +
  labs(x = "Condition", y = "Recognition test score (standardized)")
) |>
  ggplotly()
```


#### False recognition

```{r plot_false_reco}
#| label: fig-false_reco_per_condition
#| fig-cap: "False recognition test standardized scores per condition and group. ***Feel free to click on the legend.*** Colored points and dotted lines represent group means for each condition. The black dotted line is the standardized mean for every condition, i.e. 0 after the centering. Black points and lines represent condition means along with 95% confidence intervals."
#| fig-height: 7

df_false_reco <-
  df_pca |>
  filter(group != "control" & condition != 0) |>
  group_by(group, condition) |>
  get_summary_stats(false_reco)

(
df_pca |>
  filter(group != "control" & condition != 0) |>
  ggplot(aes(
    x = factor(condition, level = c("4", "3", "2", "1")),
    y = false_reco
  )) +
  geom_hline(
    yintercept = mean(df_pca$false_reco),
    linetype = 2
    ) +
  geom_beeswarm(aes(
    group = group,
    color = group
    ),
    alpha = .4
  ) +
  geom_line(
    data = df_false_reco,
    aes(
      x = condition,
      y = mean,
      group = group,
      color = group
      ),
    linetype = 3
  ) +
  geom_point(
    data = df_false_reco,
    aes(
      x = condition,
      y = mean,
      group = group,
      color = group)
  ) +
  geom_pointrange(
    data = df_pca |>
      filter(group != "control" & condition != 0) |>
      group_by(condition) |>
      get_summary_stats(false_reco),
    aes(
      x = condition,
      y = mean,
      ymin = mean - ci,
      ymax = mean + ci
      ),
    color = "black",
    size = 2
  ) +
  geom_line(
    data = df_pca |>
      filter(group != "control" & condition != 0) |>
      group_by(condition) |>
      get_summary_stats(false_reco),
    aes(
      x = condition,
      y = mean,
      group = 1
      ),
    color = "black",
    size = 1
  ) +
  coord_cartesian(ylim = c(-2,2)) +
  scale_color_viridis_d(name = "Group") +
  labs(x = "Condition", y = "False recognition test score (standardized)")
) |>
  ggplotly()
```


#### Visuo-spatial WM

```{r plot_visuo_spa_wm}
#| label: fig-visuo_spa_wm_per_condition
#| fig-cap: "Visuo-spatial working memory standardized scores per condition and group. ***Feel free to click on the legend.*** Colored points and dotted lines represent group means for each condition. The black dotted line is the standardized mean for every condition, i.e. 0 after the centering. Black points and lines represent condition means along with 95% confidence intervals."
#| fig-height: 7

df_vis_spa_wm <-
  df_pca |>
  filter(group != "control" & condition != 0) |>
  group_by(group, condition) |>
  get_summary_stats(vis_spa_wm)

(
df_pca |>
  filter(group != "control" & condition != 0) |>
  ggplot(aes(
    x = factor(condition, level = c("4", "3", "2", "1")),
    y = reco
  )) +
  geom_hline(
    yintercept = mean(df_pca$vis_spa_wm),
    linetype = 2
    ) +
  geom_beeswarm(aes(
    group = group,
    color = group
    ),
    alpha = .4
  ) +
  geom_line(
    data = df_vis_spa_wm,
    aes(
      x = condition,
      y = mean,
      group = group,
      color = group
      ),
    linetype = 3
  ) +
  geom_point(
    data = df_vis_spa_wm,
    aes(
      x = condition,
      y = mean,
      group = group,
      color = group)
  ) +
  geom_pointrange(
    data = df_pca |>
      filter(group != "control" & condition != 0) |>
      group_by(condition) |>
      get_summary_stats(vis_spa_wm),
    aes(
      x = condition,
      y = mean,
      ymin = mean - ci,
      ymax = mean + ci
      ),
    color = "black",
    size = 2
  ) +
  geom_line(
    data = df_pca |>
      filter(group != "control" & condition != 0) |>
      group_by(condition) |>
      get_summary_stats(vis_spa_wm),
    aes(
      x = condition,
      y = mean,
      group = 1
      ),
    color = "black",
    size = 1
  ) +
  coord_cartesian(ylim = c(-2,2)) +
  scale_color_viridis_d(name = "Group") +
  labs(x = "Condition", y = "Visuo-spatial WM score (standardized)")
) |>
  ggplotly()
```


#### Attention

```{r plot_attention}
#| label: fig-attention_per_condition
#| fig-cap: "Attention standardized scores per condition and group. ***Feel free to click on the legend.*** Colored points and dotted lines represent group means for each condition. The black dotted line is the standardized mean for every condition, i.e. 0 after the centering. Black points and lines represent condition means along with 95% confidence intervals."
#| fig-height: 7

df_attention <-
  df_pca |>
  filter(group != "control" & condition != 0) |>
  group_by(group, condition) |>
  get_summary_stats(attention)

(
df_pca |>
  filter(group != "control" & condition != 0) |>
  ggplot(aes(
    x = factor(condition, level = c("4", "3", "2", "1")),
    y = attention
  )) +
  geom_hline(
    yintercept = mean(df_pca$attention),
    linetype = 2
    ) +
  geom_beeswarm(aes(
    group = group,
    color = group
    ),
    alpha = .4
  ) +
  geom_line(
    data = df_attention,
    aes(
      x = condition,
      y = mean,
      group = group,
      color = group
      ),
    linetype = 3
  ) +
  geom_point(
    data = df_attention,
    aes(
      x = condition,
      y = mean,
      group = group,
      color = group)
  ) +
  geom_pointrange(
    data = df_pca |>
      filter(group != "control" & condition != 0) |>
      group_by(condition) |>
      get_summary_stats(attention),
    aes(
      x = condition,
      y = mean,
      ymin = mean - ci,
      ymax = mean + ci
      ),
    color = "black",
    size = 2
  ) +
  geom_line(
    data = df_pca |>
      filter(group != "control" & condition != 0) |>
      group_by(condition) |>
      get_summary_stats(attention),
    aes(
      x = condition,
      y = mean,
      group = 1
      ),
    color = "black",
    size = 1
  ) +
  coord_cartesian(ylim = c(-2,2)) +
  scale_color_viridis_d(name = "Group") +
  labs(x = "Condition", y = "Attention score (standardized)")
) |>
  ggplotly()
```


#### Reasoning (PCA)

```{r plot_pc1}
#| label: fig-reasoning_per_condition
#| fig-cap: "Reasoning standardized scores per condition and group. ***Feel free to click on the legend.*** Colored points and dotted lines represent group means for each condition. The black dotted line is the standardized mean for every condition, i.e. 0 after the centering. Black points and lines represent condition means along with 95% confidence intervals."
#| fig-height: 7

df_reasoning <-
  df_pca |>
  filter(group != "control" & condition != 0) |>
  group_by(group, condition) |>
  get_summary_stats(pca_reasoning)

(
df_pca |>
  filter(group != "control" & condition != 0) |>
  ggplot(aes(
    x = factor(condition, level = c("4", "3", "2", "1")),
    y = pca_reasoning
  )) +
  geom_hline(
    yintercept = mean(df_pca$pca_reasoning),
    linetype = 2
    ) +
  geom_beeswarm(aes(
    group = group,
    color = group
    ),
    alpha = .4
  ) +
  geom_line(
    data = df_reasoning,
    aes(
      x = condition,
      y = mean,
      group = group,
      color = group
      ),
    linetype = 3
  ) +
  geom_point(
    data = df_reasoning,
    aes(
      x = condition,
      y = mean,
      group = group,
      color = group)
  ) +
  geom_pointrange(
    data = df_pca |>
      filter(group != "control" & condition != 0) |>
      group_by(condition) |>
      get_summary_stats(pca_reasoning),
    aes(
      x = condition,
      y = mean,
      ymin = mean - ci,
      ymax = mean + ci
      ),
    color = "black",
    size = 2
  ) +
  geom_line(
    data = df_pca |>
      filter(group != "control" & condition != 0) |>
      group_by(condition) |>
      get_summary_stats(pca_reasoning),
    aes(
      x = condition,
      y = mean,
      group = 1
      ),
    color = "black",
    size = 1
  ) +
  coord_cartesian(ylim = c(-2,2)) +
  scale_color_viridis_d(name = "Group") +
  labs(x = "Condition", y = "Reasoning score (standardized, PCA variable)")
) |>
  ggplotly()
```


#### False recognition (PCA)

```{r plot_pc2}
#| label: fig-false_reco_pc2_per_condition
#| fig-cap: "False recognition standardized scores per condition and group. ***Feel free to click on the legend.*** Colored points and dotted lines represent group means for each condition. The black dotted line is the standardized mean for every condition, i.e. 0 after the centering. Black points and lines represent condition means along with 95% confidence intervals."
#| fig-height: 7

df_pca_false_reco <-
  df_pca |>
  filter(group != "control" & condition != 0) |>
  group_by(group, condition) |>
  get_summary_stats(pca_false_reco)

(
df_pca |>
  filter(group != "control" & condition != 0) |>
  ggplot(aes(
    x = factor(condition, level = c("4", "3", "2", "1")),
    y = pca_false_reco
  )) +
  geom_hline(
    yintercept = mean(df_pca$pca_false_reco),
    linetype = 2
    ) +
  geom_beeswarm(aes(
    group = group,
    color = group
    ),
    alpha = .4
  ) +
  geom_line(
    data = df_pca_false_reco,
    aes(
      x = condition,
      y = mean,
      group = group,
      color = group
      ),
    linetype = 3
  ) +
  geom_point(
    data = df_pca_false_reco,
    aes(
      x = condition,
      y = mean,
      group = group,
      color = group)
  ) +
  geom_pointrange(
    data = df_pca |>
      filter(group != "control" & condition != 0) |>
      group_by(condition) |>
      get_summary_stats(pca_false_reco),
    aes(
      x = condition,
      y = mean,
      ymin = mean - ci,
      ymax = mean + ci
      ),
    color = "black",
    size = 2
  ) +
  geom_line(
    data = df_pca |>
      filter(group != "control" & condition != 0) |>
      group_by(condition) |>
      get_summary_stats(pca_false_reco),
    aes(
      x = condition,
      y = mean,
      group = 1
      ),
    color = "black",
    size = 1
  ) +
  coord_cartesian(ylim = c(-2,2)) +
  scale_color_viridis_d(name = "Group") +
  labs(x = "Condition", y = "False recognition score (standardized, PCA variable)")
) |>
  ggplotly()
```


#### Working memory (PCA)

```{r plot_pc3}
#| label: fig-wm_per_condition
#| fig-cap: "Working memory standardized scores per condition and group. ***Feel free to click on the legend.*** Colored points and dotted lines represent group means for each condition. The black dotted line is the standardized mean for every condition, i.e. 0 after the centering. Black points and lines represent condition means along with 95% confidence intervals."
#| fig-height: 7

df_wm <-
  df_pca |>
  filter(group != "control" & condition != 0) |>
  group_by(group, condition) |>
  get_summary_stats(pca_wm)

(
df_pca |>
  filter(group != "control" & condition != 0) |>
  ggplot(aes(
    x = factor(condition, level = c("4", "3", "2", "1")),
    y = pca_wm
  )) +
  geom_hline(
    yintercept = mean(df_pca$pca_wm),
    linetype = 2
    ) +
  geom_beeswarm(aes(
    group = group,
    color = group
    ),
    alpha = .4
  ) +
  geom_line(
    data = df_wm,
    aes(
      x = condition,
      y = mean,
      group = group,
      color = group
      ),
    linetype = 3
  ) +
  geom_point(
    data = df_wm,
    aes(
      x = condition,
      y = mean,
      group = group,
      color = group)
  ) +
  geom_pointrange(
    data = df_pca |>
      filter(group != "control" & condition != 0) |>
      group_by(condition) |>
      get_summary_stats(pca_wm),
    aes(
      x = condition,
      y = mean,
      ymin = mean - ci,
      ymax = mean + ci
      ),
    color = "black",
    size = 2
  ) +
  geom_line(
    data = df_pca |>
      filter(group != "control" & condition != 0) |>
      group_by(condition) |>
      get_summary_stats(pca_wm),
    aes(
      x = condition,
      y = mean,
      group = 1
      ),
    color = "black",
    size = 1
  ) +
  coord_cartesian(ylim = c(-2,2)) +
  scale_color_viridis_d(name = "Group") +
  labs(x = "Condition", y = "Working memory score (standardized, PCA variable)")
) |>
  ggplotly()
```

:::

The condition 1, with outdoor activities and sensorimotor training, appears to be associated with higher scores in *comprehension*, *categorization*, and the reasoning PCA variable - which is coherent considering that this variable is extracted mostly from the former two.

### Groups and sessions

The only way to study outcome differences *across time* - i.e. the progression of children across weeks - is to compare each group in each session, but also comparing experimental groups as a whole to the control group. This perspective for each outcome is in @fig-comprehension_per_session and subsequent tabs.

:::{.panel-tabset .column-page-right}

#### Comprehension

```{r comprehension_session}
#| label: fig-comprehension_per_session
#| fig-cap: "Comprehension standardized scores per group across sessions. ***Feel free to click on the legend.*** Colored transparent solid lines connect the raw mean scores of each group at each session. Colored transparent dashed lines represent non-linear polynomial regressions fit on the score for each group, mainly to ease the vizualisation of the patterns of evolution.  Black dashed and dot-dashed lines represent linear regressions fit on the score for the four experimental groups gathered (dot-dashed line) or the control group (long-dashed line)."
#| fig-height: 6

df_comp_per_session <-
  df_pca |>
  group_by(group, session) |>
  get_summary_stats(comprehension)

df_comp_expe_groups <-
  df_pca |>
  group_by(expe_group, session) |>
  get_summary_stats(comprehension) |> 
  mutate(session = as.numeric(session))

(
df_pca |>
  ggplot(aes(
    x = session,
    y = comprehension,
    group = group, 
    color = group
    )
  ) +
  geom_line(
    data = df_comp_per_session,
    aes(
      x = session,
      y = mean,
      group = group,
      color = group
      ),
    linetype = "solid",
    linewidth = .5,
    alpha = .15
  ) +
  geom_line(
    data = df_comp_per_session |> mutate(session = as.numeric(session)),
    aes(
      x = session,
      y = mean,
      group = group,
      color = group
    ),
    stat = "smooth",
    method = "loess",
    span = 3,
    alpha = .3,
    linetype = "dashed",
    linewidth = 1
  ) +
  geom_smooth(
    data = df_comp_expe_groups,
    aes(
      x = session,
      y = mean,
      group = expe_group,
      linetype = expe_group
    ),
    method = "lm",
    level = .95,
    se = FALSE,
    color = "black",
    alpha = .1,
    linewidth = 1.3
  ) +
  coord_cartesian(ylim = c(-.5,.5)) +
  scale_linetype_manual(name = NULL,values = c("longdash", "dotdash")) +
  scale_color_viridis_d(name = "Group") +
  labs(x = "Session", y = "Comprehension score (standardized)")
) |> ggplotly()
```

#### Categorization

```{r categorization_session}
#| label: fig-categorization_per_session
#| fig-cap: "Categorization standardized scores per group across sessions. ***Feel free to click on the legend.*** Colored transparent solid lines connect the raw mean scores of each group at each session. Colored transparent dashed lines represent non-linear polynomial regressions fit on the score for each group, mainly to ease the vizualisation of the patterns of evolution.  Black dashed and dot-dashed lines represent linear regressions fit on the score for the four experimental groups gathered (dot-dashed line) or the control group (long-dashed line)."
#| fig-height: 6

df_cat_per_session <-
  df_pca |>
  group_by(group, session) |>
  get_summary_stats(categorization)

df_cat_expe_groups <-
  df_pca |>
  group_by(expe_group, session) |>
  get_summary_stats(categorization) |>
  mutate(session = as.numeric(session))

(
df_pca |>
  ggplot(aes(
    x = session,
    y = categorization,
    group = group,
    color = group
    )
  ) +
  geom_line(
    data = df_cat_per_session,
    aes(
      x = session,
      y = mean,
      group = group,
      color = group
      ),
    linetype = "solid",
    linewidth = .5,
    alpha = .15
  ) +
  geom_line(
    data = df_cat_per_session |> mutate(session = as.numeric(session)),
    aes(
      x = session,
      y = mean,
      group = group,
      color = group
    ),
    stat = "smooth",
    method = "loess",
    span = 3,
    alpha = .3,
    linetype = "dashed",
    linewidth = 1
  ) +
  geom_smooth(
    data = df_cat_expe_groups,
    aes(
      x = session,
      y = mean,
      group = expe_group,
      linetype = expe_group
    ),
    method = "lm",
    level = .95,
    se = FALSE,
    color = "black",
    alpha = .1,
    linewidth = 1.3
  ) +
  coord_cartesian(ylim = c(-.5,.5)) +
  scale_linetype_manual(name = NULL,values = c("longdash", "dotdash")) +
  scale_color_viridis_d(name = "Group") +
  labs(x = "Session", y = "Categorization score (standardized)")
) |> ggplotly()
```

#### Visuo-spatial test

```{r visuo_spatial_session}
#| label: fig-visuo_spatial_per_session
#| fig-cap: "Visuo-spatial standardized scores per group across sessions. ***Feel free to click on the legend.*** Colored transparent solid lines connect the raw mean scores of each group at each session. Colored transparent dashed lines represent non-linear polynomial regressions fit on the score for each group, mainly to ease the vizualisation of the patterns of evolution.  Black dashed and dot-dashed lines represent linear regressions fit on the score for the four experimental groups gathered (dot-dashed line) or the control group (long-dashed line)."
#| fig-height: 6

df_visuo_spa_per_session <-
  df_pca |>
  group_by(group, session) |>
  get_summary_stats(visuo_spatial)

df_visuo_spa_expe_groups <-
  df_pca |>
  group_by(expe_group, session) |>
  get_summary_stats(visuo_spatial) |>
  mutate(session = as.numeric(session))

(
df_pca |>
  ggplot(aes(
    x = session,
    y = visuo_spatial,
    group = group,
    color = group
    )
  ) +
  geom_line(
    data = df_visuo_spa_per_session,
    aes(
      x = session,
      y = mean,
      group = group,
      color = group
      ),
    linetype = "solid",
    linewidth = .5,
    alpha = .15
  ) +
  geom_line(
    data = df_visuo_spa_per_session |> mutate(session = as.numeric(session)),
    aes(
      x = session,
      y = mean,
      group = group,
      color = group
    ),
    stat = "smooth",
    method = "loess",
    span = 3,
    alpha = .3,
    linetype = "dashed",
    linewidth = 1
  ) +
  geom_smooth(
    data = df_visuo_spa_expe_groups,
    aes(
      x = session,
      y = mean,
      group = expe_group,
      linetype = expe_group
    ),
    method = "lm",
    level = .95,
    se = FALSE,
    color = "black",
    alpha = .1,
    linewidth = 1.3
  ) +
  coord_cartesian(ylim = c(-.5,.5)) +
  scale_linetype_manual(name = NULL,values = c("longdash", "dotdash")) +
  scale_color_viridis_d(name = "Group") +
  labs(x = "Session", y = "Visuo-spatial test score (standardized)")
) |> ggplotly()
```

#### Recognition

```{r recognitiion_session}
#| label: fig-recognition_per_session
#| fig-cap: "Recognition standardized scores per group across sessions. ***Feel free to click on the legend.*** Colored transparent solid lines connect the raw mean scores of each group at each session. Colored transparent dashed lines represent non-linear polynomial regressions fit on the score for each group, mainly to ease the vizualisation of the patterns of evolution.  Black dashed and dot-dashed lines represent linear regressions fit on the score for the four experimental groups gathered (dot-dashed line) or the control group (long-dashed line)."
#| fig-height: 6

df_reco_per_session <-
  df_pca |>
  group_by(group, session) |>
  get_summary_stats(reco)

df_reco_expe_groups <-
  df_pca |>
  group_by(expe_group, session) |>
  get_summary_stats(reco) |>
  mutate(session = as.numeric(session))

(
df_pca |>
  ggplot(aes(
    x = session,
    y = reco,
    group = group,
    color = group
    )
  ) +
  geom_line(
    data = df_reco_per_session,
    aes(
      x = session,
      y = mean,
      group = group,
      color = group
      ),
    linetype = "solid",
    linewidth = .5,
    alpha = .15
  ) +
  geom_line(
    data = df_reco_per_session |> mutate(session = as.numeric(session)),
    aes(
      x = session,
      y = mean,
      group = group,
      color = group
    ),
    stat = "smooth",
    method = "loess",
    span = 3,
    alpha = .3,
    linetype = "dashed",
    linewidth = 1
  ) +
  geom_smooth(
    data = df_reco_expe_groups,
    aes(
      x = session,
      y = mean,
      group = expe_group,
      linetype = expe_group
    ),
    method = "lm",
    level = .95,
    se = FALSE,
    color = "black",
    alpha = .1,
    linewidth = 1.3
  ) +
  coord_cartesian(ylim = c(-.5,.5)) +
  scale_linetype_manual(name = NULL,values = c("longdash", "dotdash")) +
  scale_color_viridis_d(name = "Group") +
  labs(x = "Session", y = "Recognition score (standardized)")
) |> ggplotly()
```

#### False recognition

```{r false_reco_session}
#| label: fig-false_reco_per_session
#| fig-cap: "False recognition standardized scores per group across sessions. ***Feel free to click on the legend.*** Colored transparent solid lines connect the raw mean scores of each group at each session. Colored transparent dashed lines represent non-linear polynomial regressions fit on the score for each group, mainly to ease the vizualisation of the patterns of evolution.  Black dashed and dot-dashed lines represent linear regressions fit on the score for the four experimental groups gathered (dot-dashed line) or the control group (long-dashed line)."
#| fig-height: 6

df_false_reco_per_session <-
  df_pca |>
  group_by(group, session) |>
  get_summary_stats(false_reco)

df_false_reco_expe_groups <-
  df_pca |>
  group_by(expe_group, session) |>
  get_summary_stats(false_reco) |>
  mutate(session = as.numeric(session))

(
df_pca |>
  ggplot(aes(
    x = session,
    y = false_reco,
    group = group,
    color = group
    )
  ) +
  geom_line(
    data = df_false_reco_per_session,
    aes(
      x = session,
      y = mean,
      group = group,
      color = group
      ),
    linetype = "solid",
    linewidth = .5,
    alpha = .15
  ) +
  geom_line(
    data = df_false_reco_per_session |> mutate(session = as.numeric(session)),
    aes(
      x = session,
      y = mean,
      group = group,
      color = group
    ),
    stat = "smooth",
    method = "loess",
    span = 3,
    alpha = .3,
    linetype = "dashed",
    linewidth = 1
  ) +
  geom_smooth(
    data = df_false_reco_expe_groups,
    aes(
      x = session,
      y = mean,
      group = expe_group,
      linetype = expe_group
    ),
    method = "lm",
    level = .95,
    se = FALSE,
    color = "black",
    alpha = .1,
    linewidth = 1.3
  ) +
  coord_cartesian(ylim = c(-.5,.5)) +
  scale_linetype_manual(name = NULL,values = c("longdash", "dotdash")) +
  scale_color_viridis_d(name = "Group") +
  labs(x = "Session", y = "False recognition score (standardized)")
) |> ggplotly()
```

#### Visuo-spatial WM

```{r vis_spa_wm_session}
#| label: fig-vis_spa_wm_per_session
#| fig-cap: "Visuo-spatial WM standardized scores per group across sessions. ***Feel free to click on the legend.*** Colored transparent solid lines connect the raw mean scores of each group at each session. Colored transparent dashed lines represent non-linear polynomial regressions fit on the score for each group, mainly to ease the vizualisation of the patterns of evolution.  Black dashed and dot-dashed lines represent linear regressions fit on the score for the four experimental groups gathered (dot-dashed line) or the control group (long-dashed line)."
#| fig-height: 6

df_vis_spa_wm_per_session <-
  df_pca |>
  group_by(group, session) |>
  get_summary_stats(vis_spa_wm)

df_vis_spa_wm_expe_groups <-
  df_pca |>
  group_by(expe_group, session) |>
  get_summary_stats(vis_spa_wm) |>
  mutate(session = as.numeric(session))

(
df_pca |>
  ggplot(aes(
    x = session,
    y = vis_spa_wm,
    group = group,
    color = group
    )
  ) +
  geom_line(
    data = df_vis_spa_wm_per_session,
    aes(
      x = session,
      y = mean,
      group = group,
      color = group
      ),
    linetype = "solid",
    linewidth = .5,
    alpha = .15
  ) +
  geom_line(
    data = df_vis_spa_wm_per_session |> mutate(session = as.numeric(session)),
    aes(
      x = session,
      y = mean,
      group = group,
      color = group
    ),
    stat = "smooth",
    method = "loess",
    span = 3,
    alpha = .3,
    linetype = "dashed",
    linewidth = 1
  ) +
  geom_smooth(
    data = df_vis_spa_wm_expe_groups,
    aes(
      x = session,
      y = mean,
      group = expe_group,
      linetype = expe_group
    ),
    method = "lm",
    level = .95,
    se = FALSE,
    color = "black",
    alpha = .1,
    linewidth = 1.3
  ) +
  coord_cartesian(ylim = c(-.5,.5)) +
  scale_linetype_manual(name = NULL,values = c("longdash", "dotdash")) +
  scale_color_viridis_d(name = "Group") +
  labs(x = "Session", y = "Visuo-spatial WM score (standardized)")
) |> ggplotly()
```

#### Attention

```{r attention_session}
#| label: fig-attention_per_session
#| fig-cap: "Attention standardized scores per group across sessions. ***Feel free to click on the legend.*** Colored transparent solid lines connect the raw mean scores of each group at each session. Colored transparent dashed lines represent non-linear polynomial regressions fit on the score for each group, mainly to ease the vizualisation of the patterns of evolution.  Black dashed and dot-dashed lines represent linear regressions fit on the score for the four experimental groups gathered (dot-dashed line) or the control group (long-dashed line)."
#| fig-height: 6

df_attention_per_session <-
  df_pca |>
  group_by(group, session) |>
  get_summary_stats(attention)

df_attention_expe_groups <-
  df_pca |>
  group_by(expe_group, session) |>
  get_summary_stats(attention) |>
  mutate(session = as.numeric(session))

(
df_pca |>
  ggplot(aes(
    x = session,
    y = attention,
    group = group,
    color = group
    )
  ) +
  geom_line(
    data = df_attention_per_session,
    aes(
      x = session,
      y = mean,
      group = group,
      color = group
      ),
    linetype = "solid",
    linewidth = .5,
    alpha = .15
  ) +
  geom_line(
    data = df_attention_per_session |> mutate(session = as.numeric(session)),
    aes(
      x = session,
      y = mean,
      group = group,
      color = group
    ),
    stat = "smooth",
    method = "loess",
    span = 3,
    alpha = .3,
    linetype = "dashed",
    linewidth = 1
  ) +
  geom_smooth(
    data = df_attention_expe_groups,
    aes(
      x = session,
      y = mean,
      group = expe_group,
      linetype = expe_group
    ),
    method = "lm",
    level = .95,
    se = FALSE,
    color = "black",
    alpha = .1,
    linewidth = 1.3
  ) +
  coord_cartesian(ylim = c(-.5,.5)) +
  scale_linetype_manual(name = NULL,values = c("longdash", "dotdash")) +
  scale_color_viridis_d(name = "Group") +
  labs(x = "Session", y = "Attention score (standardized)")
) |> ggplotly()
```

#### Reasoning (PCA)

```{r pca_reasoning_session}
#| label: fig-pca_reasoning_per_session
#| fig-cap: "Reasoning (PCA variable) standardized scores per group across sessions. Colored transparent solid lines connect the raw mean scores of each group at each session. ***Feel free to click on the legend.*** Colored transparent dashed lines represent non-linear polynomial regressions fit on the score for each group, mainly to ease the vizualisation of the patterns of evolution.  Black dashed and dot-dashed lines represent linear regressions fit on the score for the four experimental groups gathered (dot-dashed line) or the control group (long-dashed line)."
#| fig-height: 6

df_pca_reasoning_per_session <-
  df_pca |>
  group_by(group, session) |>
  get_summary_stats(pca_reasoning)

df_pca_reasoning_expe_groups <-
  df_pca |>
  group_by(expe_group, session) |>
  get_summary_stats(pca_reasoning) |>
  mutate(session = as.numeric(session))

(
df_pca |>
  ggplot(aes(
    x = session,
    y = pca_reasoning,
    group = group,
    color = group
    )
  ) +
  geom_line(
    data = df_pca_reasoning_per_session,
    aes(
      x = session,
      y = mean,
      group = group,
      color = group
      ),
    linetype = "solid",
    linewidth = .5,
    alpha = .15
  ) +
  geom_line(
    data = df_pca_reasoning_per_session |> mutate(session = as.numeric(session)),
    aes(
      x = session,
      y = mean,
      group = group,
      color = group
    ),
    stat = "smooth",
    method = "loess",
    span = 3,
    alpha = .3,
    linetype = "dashed",
    linewidth = 1
  ) +
  geom_smooth(
    data = df_pca_reasoning_expe_groups,
    aes(
      x = session,
      y = mean,
      group = expe_group,
      linetype = expe_group
    ),
    method = "lm",
    level = .95,
    se = FALSE,
    color = "black",
    alpha = .1,
    linewidth = 1.3
  ) +
  coord_cartesian(ylim = c(-.5,.5)) +
  scale_linetype_manual(name = NULL,values = c("longdash", "dotdash")) +
  scale_color_viridis_d(name = "Group") +
  labs(x = "Session", y = "Reasoning score (standardized, PCA variable)")
) |> ggplotly()
```

#### False recognition (PCA)

```{r pca_false_reco_session}
#| label: fig-pca_false_reco_per_session
#| fig-cap: "False recognition (PCA variable) standardized scores per group across sessions. ***Feel free to click on the legend.*** Colored transparent solid lines connect the raw mean scores of each group at each session. Colored transparent dashed lines represent non-linear polynomial regressions fit on the score for each group, mainly to ease the vizualisation of the patterns of evolution. Black dashed and dot-dashed lines represent linear regressions fit on the score for the four experimental groups gathered (dot-dashed line) or the control group (long-dashed line)."
#| fig-height: 6

df_pca_false_reco_per_session <-
  df_pca |>
  group_by(group, session) |>
  get_summary_stats(pca_false_reco)

df_pca_false_reco_expe_groups <-
  df_pca |>
  group_by(expe_group, session) |>
  get_summary_stats(pca_false_reco) |>
  mutate(session = as.numeric(session))

(
df_pca |>
  ggplot(aes(
    x = session,
    y = pca_false_reco,
    group = group,
    color = group
    )
  ) +
  geom_line(
    data = df_pca_false_reco_per_session,
    aes(
      x = session,
      y = mean,
      group = group,
      color = group
      ),
    linetype = "solid",
    linewidth = .5,
    alpha = .15
  ) +
  geom_line(
    data = df_pca_false_reco_per_session |> mutate(session = as.numeric(session)),
    aes(
      x = session,
      y = mean,
      group = group,
      color = group
    ),
    stat = "smooth",
    method = "loess",
    span = 3,
    alpha = .3,
    linetype = "dashed",
    linewidth = 1
  ) +
  geom_smooth(
    data = df_pca_false_reco_expe_groups,
    aes(
      x = session,
      y = mean,
      group = expe_group,
      linetype = expe_group
    ),
    method = "lm",
    level = .95,
    se = FALSE,
    color = "black",
    alpha = .1,
    linewidth = 1.3
  ) +
  coord_cartesian(ylim = c(-.5,.5)) +
  scale_linetype_manual(name = NULL,values = c("longdash", "dotdash")) +
  scale_color_viridis_d(name = "Group") +
  labs(x = "Session", y = "False recognition score (standardized, PCA variable)")
) |> ggplotly()
```

#### Working memory (PCA)

```{r pca_wm_session}
#| label: fig-pca_wm_per_session
#| fig-cap: "Working memory (PCA variable) standardized scores per group across sessions. ***Feel free to click on the legend.*** Colored transparent solid lines connect the raw mean scores of each group at each session. Colored transparent dashed lines represent non-linear polynomial regressions fit on the score for each group, mainly to ease the vizualisation of the patterns of evolution. Black dashed and dot-dashed lines represent linear regressions fit on the score for the four experimental groups gathered (dot-dashed line) or the control group (long-dashed line)."
#| fig-height: 6

df_pca_wm_per_session <-
  df_pca |>
  group_by(group, session) |>
  get_summary_stats(pca_wm)

df_pca_wm_expe_groups <-
  df_pca |>
  group_by(expe_group, session) |>
  get_summary_stats(pca_wm) |>
  mutate(session = as.numeric(session))

(
df_pca |>
  ggplot(aes(
    x = session,
    y = pca_wm,
    group = group,
    color = group
    )
  ) +
  geom_line(
    data = df_pca_wm_per_session,
    aes(
      x = session,
      y = mean,
      group = group,
      color = group
      ),
    linetype = "solid",
    linewidth = .5,
    alpha = .15
  ) +
  geom_line(
    data = df_pca_wm_per_session |> mutate(session = as.numeric(session)),
    aes(
      x = session,
      y = mean,
      group = group,
      color = group
    ),
    stat = "smooth",
    method = "loess",
    span = 3,
    alpha = .3,
    linetype = "dashed",
    linewidth = 1
  ) +
  geom_smooth(
    data = df_pca_wm_expe_groups,
    aes(
      x = session,
      y = mean,
      group = expe_group,
      linetype = expe_group
    ),
    method = "lm",
    level = .95,
    se = FALSE,
    color = "black",
    alpha = .1,
    linewidth = 1.3
  ) +
  coord_cartesian(ylim = c(-.5,.5)) +
  scale_linetype_manual(name = NULL,values = c("longdash", "dotdash")) +
  scale_color_viridis_d(name = "Group") +
  labs(x = "Session", y = "Working memory score (standardized, PCA variable)")
) |> ggplotly()
```

:::

# Inferential analysis {#sec-inferential}

## Model description

### Research question and variables

Our analysis aims at answering the following question: do the outdoor activities and sensory trainings improve the children's learning abilities?

WIP - *We still have a bit more work to do to choose appropriate multilevel (aka mixed) model structures (fixed or random effects, etc.).*

### Potential models

WIP - *Basically we will build the statistical models underlying the figures displayed above, and see if the effects we see here empirically are significant/large.*


<!-- old code -->
```{r recipe}
#_______________________________________________________________________________
# # Doesn't seem to work for some reason
# recipe_model <-
#   df_norm |>
#   recipe() |>
#   update_role(
#     comprehension,
#     categorization,
#     visuo_spatial,
#     reco,
#     vis_spa_wm,
#     attention,
#     new_role = "outcome"
#   ) |>
#   update_role(
#     session,
#     condition,
#     age,
#     new_role = "predictor"
#   ) |>
#   update_role(
#     subject,
#     group,
#     new_role = "group"
#   ) |>
#   step_BoxCox(comprehension)
#
# recipe_model |>
#   prep() |>
#   bake(df_norm)
```









